// AVL self balancing search tree, node based
// tree node: n.left, n.right, n.height, n.key, n.val
// balance factor (BF): n.right.height - n.left.height
// AVL must maintain each nodes' BF to be within [-1, 1];

// reference: https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/83cdd705cd418d10d9769b741e34a2b8_MIT6_006F11_lec06.pdf

fun max(a, b) { if (a<b) return b; else return a; }
fun height(root) {
	if (root==nil) return -1;
	return root.height; 
}
fun update_height(root) {
	assert(root != nil);
	root.height = max(height(root.left), height(root.right)) + 1; 
}
// rotate root left, return the new root
// update the height
fun left_rotate(root) {
	assert(root.right != nil); 
	var y = root.right;
	root.right = y.left;
	y.left = root;
	update_height(root);
	update_height(y); 
	return y; 
}

fun right_rotate(root) {
	var y = root.left;
	root.left = y.right;
	y.right = root;
	update_height(root);
	update_height(y); 
	return y; 
}

// insert (key,val) into the AVL tree, only if key is not tree;
// otherwise do nothing
fun avl_insert(root, key, val, less) {
	if (root == nil) {
		return {"left": nil, "right": nil, "key": key, "val": val, "height": 0};
	}
	if (key == root.key) return root; 
	if (key < root.key)
		root.left = avl_insert(root.left, key, val, less);
	else
		root.right = avl_insert(root.right, key, val, less); 

	var left_height = height(root.left); 
	var right_height = height(root.right); 

	// now, rotate trees if it becomes unbalanced. Four situations
	if (left_height +2 == right_height) { // right heavy
		assert(root.right != nil);
		if (height(root.right.left) <=  height(root.right.right)) {// right child right heavy or balanced
			root = left_rotate(root); 
		} else {
			root.right = right_rotate(root.right);
			root = left_rotate(root); 
		}
	} else if (left_height == right_height + 2) {
		assert(root.left != nil);
		if (height(root.left.left) >= height(root.left.right)) {
			root = right_rotate(root); 
		} else {
			root.left = left_rotate(root.left);
			root = right_rotate(root); 
		}
	} else {
		// no rotation. just update height
		update_height(root); 
	}
	
	return root; 
}

// return the key-value pair if found;
// otherwise return nil
fun avl_find(root, key, less) {
	if (root == nil) return nil;
	assert(root.key != nil); 
	if (root.key == key) return [root.key, root.val];
	else if (less(key, root.key))
		return avl_find(root.left, key, less);
	else
		return avl_find(root.right, key, less); 
}

// returns the [new_root, key, val]
fun avl_extract_min(root, less) {
	assert( root != nil );
	if (root.left == nil) { 
		// root is the min in the subtree rooted at `root`; remove it
		return [root.right, root.key, root.val];
	}
	// otherwise go left sub tree; (min is always in the left)
	var res = avl_extract_min(root.left, less);
	root.left = res[0];
	res[0] = root;
	// after removal, the tree might become unbalanced; rotate if needed
	
	var left_height = height(root.left); 
	var right_height = height(root.right); 

	// now, rotate trees if it becomes unbalanced. Four situations
	if (left_height +2 == right_height) { // right heavy
		assert(root.right != nil);
		if (height(root.right.left) <=  height(root.right.right)) {// right child right heavy or balanced
			root = left_rotate(root); 
		} else {
			root.right = right_rotate(root.right);
			root = left_rotate(root); 
		}
	} else {
		// no rotation. just update height
		update_height(root); 
	}
	res[0] = root;
	return res; 
}

// returns the [new_root, key, val]
fun avl_extract_max(root, less) {
	assert( root != nil );
	if (root.right == nil) { 
		// root is the min in the subtree rooted at `root`; remove it
		return [root.left, root.key, root.val];
	}
	// otherwise go left sub tree; (min is always in the left)
	var res = avl_extract_max(root.right, less);
	root.right = res[0];
	res[0] = root;
	// after removal, the tree might become unbalanced; rotate if needed
	
	var left_height = height(root.left); 
	var right_height = height(root.right); 

	if (left_height == right_height + 2) {
		assert(root.left != nil);
		if (height(root.left.left) >= height(root.left.right)) {
			root = right_rotate(root); 
		} else {
			root.left = left_rotate(root.left);
			root = right_rotate(root); 
		}
	} else {
		// no rotation. just update height
		update_height(root); 
	}

	res[0] = root;
	return res; 
}

// if key exists in the AVL tree rooted at root, then
// remove it, and return its [key, val].
// otherwise return nil and do nothing to the AVL tree. 
fun avl_extract(root, key, less) {
	if (root == nil) {
		return root; 
	}
	if (key == root.key) {
		if (root.left == nil and root.right == nil) {
			return nil; 
		}
		if (root.left != nil and root.right == nil) {
			return root.left; 
		}
		if (root.right != nil and root.left == nil) {
			return root.right;
		}
		// in following case, the node root has two children;
		// replace with the in-order successor (the leftest 
		
	}

		
	if (key < root.key)
		root.left = avl_insert(root.left, key, val, less);
	else
		root.right = avl_insert(root.right, key, val, less); 

	var left_height = height(root.left); 
	var right_height = height(root.right); 

	// now, rotate trees if it becomes unbalanced. Four situations
	if (left_height +2 == right_height) { // right heavy
		assert(root.right != nil);
		if (height(root.right.left) <=  height(root.right.right)) {// right child right heavy or balanced
			root = left_rotate(root); 
		} else {
			root.right = right_rotate(root.right);
			root = left_rotate(root); 
		}
	} else if (left_height == right_height + 2) {
		assert(root.left != nil);
		if (height(root.left.left) >= height(root.left.right)) {
			root = right_rotate(root); 
		} else {
			root.left = left_rotate(root.left);
			root = right_rotate(root); 
		}
	} else {
		// no rotation. just update height
		update_height(root); 
	}
	
}


root = {
	"left": {
		"left": {                      // 11
			"left": nil,
			"right": nil,
			"key": 11,
			"val": nil,
			"height": 0
		},
		"right": {                     // 29
			"left": {                    // 26
				"left": nil,
				"right": nil,
				"key": 26,
				"val": nil,
				"height": 0
			},
			"right": nil,
			"key": 29,
			"val": nil,
			"height": 1
		},
		"key": 20,                     // 20
		"val": nil,
		"height": 2
	},
	"right": {                       // 65
		"left": {                      // 50
			"left": nil,
			"right": nil,
			"key": 50,
			"val": nil,
			"height": 0
		},
		"right": nil,
		"key": 65,
		"val": "you found it!",
		"height": 1
	},
	"key": 41,                       // root
	"val": nil,
	"height": 3
};

var less = fun(a,b){return a<b;};

fun print_binary_tree(root, indent) {
	if (root == nil) return;
	if (root.left != nil) print_binary_tree(root.left, indent + "    ");
	printf("%sK%d(%d)\n", indent, root.key, root.height); 
	if (root.right!= nil) print_binary_tree(root.right, indent+ "    "); 
}
print_binary_tree(root, "");

// returns the maximum key of the AVL tree 
fun avl_max(root) {
	assert(root);
	if (root.right == nil ) return root.key;
	return avl_max(root.right); 
}
fun avl_min(root) {
	assert(root);
	if (root.left == nil) return root.key;
	return avl_min(root.left); 
}


fun avl_size(root) {
	if (root == nil) return 0;
	return 1+avl_size(root.left)+avl_size(root.right);
}

// returns whether root is a balanced search tree. 
fun check_avl(root) {

	if (root==nil) return true;
	
	if (root.left != nil and avl_max(root.left) > root.key)
		return false;
	if (root.right != nil and avl_min(root.right) < root.key)
		return false;

	var left = height(root.left);
	var right = height(root.right);

	if (left - right <= -2 or left -right >=2) return false;
	if (check_avl(root.left) == false or check_avl(root.right) == false)
		return false; 

	return true; 
}

var key = 23; 
avl_insert(root, key, key, fun(a,b){return a<b;});
printf("\ninserting %d\n", 23); 
print_binary_tree(root, ""); 

key = 55;
avl_insert(root, key, key, fun(a,b){return a<b;});
printf("\ninserting %d\n", 55); 
print_binary_tree(root, "");

key = 35;
avl_insert(root, key, key, fun(a,b){return a<b;});
printf("\ninserting %d\n", 35); 
print_binary_tree(root, ""); 

key = 38;
avl_insert(root, key, key, fun(a,b){return a<b;});
printf("\ninserting %d\n", key); 
print_binary_tree(root, "");

for (var i=0; i<5; i=i+1) {
	var res = avl_extract_min(root, less);
	root = res[0]; 
	// print_binary_tree(res[0], "");
	printf("min key: %s val: %s\n", res[1], res[2]);
	assert(check_avl(root));
}

for (var i=0; i<5; i=i+1) {
	var res = avl_extract_max(root, less);
	root = res[0]; 
	// print_binary_tree(res[0], "");
	printf("max key: %s val: %s\n", res[1], res[2]);
	assert(check_avl(root));
	if (avl_size(root) == 0) break; 
}


print check_avl(root); 
var B = random_int(0, 1000, 200);
//print B;

for (var i=0; i<len(B); i=i+1) {
	root = avl_insert(root, B[i], B[i], fun(a,b){return a<b;});
	// assert(check_avl(root)); 
}

// avl_insert(root, 240,240, fun(a,b){return a<b;});
// print_binary_tree(root, ""); // this prints is very big so commented here
assert(check_avl(root)); 
printf("size of avl tree: %d\n", avl_size(root));


print avl_find(root, 65, fun(a,b){return a<b;});  // expect [65, "you found it!"]
print avl_find(root, 64, fun(a,b){return a<b;}); // expect nil


root2 = nil;

root2 = avl_insert(root2, 1, "first", less);
root2 = avl_insert(root2, 1, "second", less);
print avl_size(root2);  // expects 1; 

