// Binary Search Tree with in-order traversal
// Node represented as a Map: {"value": val, "left": left_node, "right": right_node}
// Note that the accessor syntax root.left is syntax sugar for root["left"]. 

// insert a new node of `value` into a binary search tree rooted at `root`
fun insert(root, value) {
    if (root == nil) return {"value": value, "left": nil, "right": nil};
    if (value < root.value)
        root.left = insert(root.left, value); 
    else
        root.right = insert(root.right, value);
    return root;
}


// print the binary tree rooted at `node`, with `depth` indent
fun print_tree(node, depth) {
    if (node == nil) return;

    print_tree(node.right, depth + 1);  // right subtree (upper part)

    // print current node with proper indentation
    var indent = "";
    for (var i = 0; i < depth; i = i + 1) {
        indent = indent + "   ";  // 4 spaces per level
    }
    printf("%s%d\n", indent, node.value);

    print_tree(node.left, depth + 1);   // left subtree (lower part)
}

var tree = nil;
var values = [5, 3, 7, 1, 9, 4, 6, 2, 8];
for (var i = 0; i < len(values); i = i + 1) {
    tree = insert(tree, values[i]);
}

print "Binary Search Tree (rotated 90Â° clockwise):";
print_tree(tree, 0);


// in-order printouts of binary tree
fun traverse_inorder(root) {
	if (root == nil) return;
	traverse_inorder(root.left);
	printf("%d ", root.value);
	traverse_inorder(root.right);
}
print "in order traversal of tree"; 
traverse_inorder(tree);
