// auto-generated by tool//Users/pwu/Code/cclox/tool/gen_ast_classes.py
#pragma once
#include "token.hpp"
#include <memory>

class Binary;
class Logical;
class Ternary;
class Grouping;
class Literal;
class Unary;
class Variable;
class Assignment;
class SubscriptAssignment;
class Call;
class ArrayLiteral;
class MapLiteral;
class Subscript;
class PropertyAccess;
class FunctionExpr;

class ExprVisitor {
public:
    virtual ~ExprVisitor() = default;

    virtual void visit(const Binary&) = 0;
    virtual void visit(const Logical&) = 0;
    virtual void visit(const Ternary&) = 0;
    virtual void visit(const Grouping&) = 0;
    virtual void visit(const Literal&) = 0;
    virtual void visit(const Unary&) = 0;
    virtual void visit(const Variable&) = 0;
    virtual void visit(const Assignment&) = 0;
    virtual void visit(const Call&) = 0;
    virtual void visit(const ArrayLiteral&) = 0;
    virtual void visit(const MapLiteral&) = 0;
    virtual void visit(const Subscript&) = 0;
    virtual void visit(const PropertyAccess&) = 0;
    virtual void visit(const SubscriptAssignment&) = 0;
    virtual void visit(const FunctionExpr&) = 0;
};

class Expr {
public:
    virtual ~Expr() = default;
    virtual void accept(ExprVisitor& visitor) const = 0;
    virtual int get_line() const = 0;
};



class Binary : public Expr {
public:
    std::unique_ptr<Expr> left;
    Token op;
    std::unique_ptr<Expr> right;

    Binary(std::unique_ptr<Expr> _left, Token _op, std::unique_ptr<Expr> _right)
        : left(std::move(_left)), op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Binary> create(
        std::unique_ptr<Expr> _left,
        Token _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Binary>(std::move(_left), _op, std::move(_right));
    }
    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return op.line;
    }
};

class Logical : public Expr {
public:
    std::unique_ptr<Expr> left;
    Token op;
    std::unique_ptr<Expr> right;

    Logical(std::unique_ptr<Expr> _left, Token _op, std::unique_ptr<Expr> _right)
        : left(std::move(_left)), op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Logical> create(
        std::unique_ptr<Expr> _left,
        Token _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Logical>(std::move(_left), _op, std::move(_right));
    }
    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return op.line;
    }
};

class Ternary : public Expr {
public:
    std::unique_ptr<Expr> condition;
    std::unique_ptr<Expr> thenBranch;
    std::unique_ptr<Expr> elseBranch;
    Token question;  // for line number reporting

    Ternary(std::unique_ptr<Expr> _condition, std::unique_ptr<Expr> _thenBranch,
            std::unique_ptr<Expr> _elseBranch, Token _question)
        : condition(std::move(_condition)), thenBranch(std::move(_thenBranch)),
          elseBranch(std::move(_elseBranch)), question(_question) {}

    static std::unique_ptr<Ternary> create(
        std::unique_ptr<Expr> _condition,
        std::unique_ptr<Expr> _thenBranch,
        std::unique_ptr<Expr> _elseBranch,
        Token _question) {
        return std::make_unique<Ternary>(std::move(_condition), std::move(_thenBranch),
                                        std::move(_elseBranch), _question);
    }
    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return question.line;
    }
};

class Grouping : public Expr {
public:
    std::unique_ptr<Expr> expression;

    Grouping(std::unique_ptr<Expr> _expression)
        : expression(std::move(_expression)) {}

    static std::unique_ptr<Grouping> create(std::unique_ptr<Expr> _expression) {
        return std::make_unique<Grouping>(std::move(_expression));
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return expression->get_line();
    }
};

class Literal : public Expr {
public:
    Value value;
    int line;

    Literal(Value _value, int line)
        : value(_value), line(line) {}

    static std::unique_ptr<Literal> create(Value _value, int line) {
        return std::make_unique<Literal>(_value, line);
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return line;
    }
};

class Unary : public Expr {
public:
    Token op;
    std::unique_ptr<Expr> right;

    Unary(const Token& _op, std::unique_ptr<Expr> _right)
        : op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Unary> create(
        const Token& _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Unary>(_op, std::move(_right));
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
    int get_line() const override {
        return op.line;
    }
};


class Variable : public Expr {
public:
    Token name;

    explicit Variable(const Token& name): name(name) {}
    static std::unique_ptr<Variable> create(const Token& name) {
        return std::make_unique<Variable>(name);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return name.line;
    }
};

class Assignment : public Expr {
public:
    Token name;
    std::unique_ptr<Expr> right;

    Assignment(const Token& _name, std::unique_ptr<Expr> _right): name(_name), right(std::move(_right)) {}
    static std::unique_ptr<Assignment> create(const Token& _name, std::unique_ptr<Expr> _right) {
        return std::make_unique<Assignment>(_name, std::move(_right));
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return name.line;
    }
};

class SubscriptAssignment : public Expr {
public:
    std::unique_ptr<Expr> object;
    std::unique_ptr<Expr> index;
    std::unique_ptr<Expr> value;
    Token bracket;  // for error reporting

    SubscriptAssignment(std::unique_ptr<Expr> object, std::unique_ptr<Expr> index,
                        std::unique_ptr<Expr> value, Token bracket)
        : object(std::move(object)), index(std::move(index)),
          value(std::move(value)), bracket(bracket) {}

    static std::unique_ptr<SubscriptAssignment> create(
        std::unique_ptr<Expr> object, std::unique_ptr<Expr> index,
        std::unique_ptr<Expr> value, Token bracket) {
        return std::make_unique<SubscriptAssignment>(
            std::move(object), std::move(index), std::move(value), bracket);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return bracket.line;  // Use the bracket token for error reporting
    }
};

class Call : public Expr {
public:
    std::unique_ptr<Expr> callee;
    Token paren;
    std::vector<std::unique_ptr<Expr>> arguments;

    Call(std::unique_ptr<Expr> _callee, Token _paren, std::vector<std::unique_ptr<Expr>> _arguments)
        : callee(std::move(_callee)), paren(_paren), arguments(std::move(_arguments)) {
    }
    static std::unique_ptr<Call> create(std::unique_ptr<Expr> _callee, Token _paren, std::vector<std::unique_ptr<Expr>> _arguments) {
        return std::make_unique<Call>(std::move(_callee), std::move(_paren), std::move(_arguments));
    }
    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return paren.line;  // Use the paren token for error reporting
    }
};

class ArrayLiteral : public Expr {
public:
    std::vector<std::unique_ptr<Expr>> elements;
    int line;

    explicit ArrayLiteral(std::vector<std::unique_ptr<Expr>> elements, int line)
        : elements(std::move(elements)), line(line) {}

    static std::unique_ptr<ArrayLiteral> create(
        std::vector<std::unique_ptr<Expr>> elements, int line) {
        return std::make_unique<ArrayLiteral>(std::move(elements), line);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return line;
    }

};

class MapLiteral : public Expr {
public:
    int line;
    std::vector<std::pair<std::unique_ptr<Expr>, std::unique_ptr<Expr>>> pairs;

    explicit MapLiteral(std::vector<std::pair<std::unique_ptr<Expr>, std::unique_ptr<Expr>>> pairs, int line)
        : pairs(std::move(pairs)), line(line) {}

    static std::unique_ptr<MapLiteral> create(
        std::vector<std::pair<std::unique_ptr<Expr>, std::unique_ptr<Expr>>> pairs,
        int line) {
        return std::make_unique<MapLiteral>(std::move(pairs), line);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return line;
    }
};

// for both array and map
class Subscript : public Expr {
public:
    std::unique_ptr<Expr> object;
    std::unique_ptr<Expr> index;
    Token bracket;  // for error reporting

    Subscript(std::unique_ptr<Expr> object, std::unique_ptr<Expr> index, Token bracket)
        : object(std::move(object)), index(std::move(index)), bracket(bracket) {}

    static std::unique_ptr<Subscript> create(
        std::unique_ptr<Expr> object, std::unique_ptr<Expr> index, Token bracket) {
        return std::make_unique<Subscript>(std::move(object), std::move(index), bracket);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return bracket.line;  // Use the bracket token for error reporting
    }
};

class PropertyAccess : public Expr {
public:
    std::unique_ptr<Expr> object;
    Token name;

    PropertyAccess(std::unique_ptr<Expr> object, Token name)
        : object(std::move(object)), name(name) {}

    static std::unique_ptr<PropertyAccess> create(
        std::unique_ptr<Expr> object, Token name) {
        return std::make_unique<PropertyAccess>(std::move(object), name);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
    int get_line() const override {
        return name.line;  // Use the property name token for error reporting
    }
};
