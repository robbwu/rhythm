// auto-generated by tool//Users/pwu/Code/cclox/tool/gen_ast_classes.py
#pragma once
#include "token.hpp"
#include <memory>

class Binary;
class Logical;
class Grouping;
class Literal;
class Unary;
class Variable;
class Assignment;
class Call;

class ExprVisitor {
public:
    virtual ~ExprVisitor() = default;

    virtual void visit(const Binary&) = 0;
    virtual void visit(const Logical&) = 0;
    virtual void visit(const Grouping&) = 0;
    virtual void visit(const Literal&) = 0;
    virtual void visit(const Unary&) = 0;
    virtual void visit(const Variable&) = 0;
    virtual void visit(const Assignment&) = 0;
    virtual void visit(const Call&) = 0;
};

class Expr {
public:
    virtual ~Expr() = default;
    virtual void accept(ExprVisitor& visitor) const = 0;
};



class Binary : public Expr {
public:
    std::unique_ptr<Expr> left;
    Token op;
    std::unique_ptr<Expr> right;

    Binary(std::unique_ptr<Expr> _left, Token _op, std::unique_ptr<Expr> _right)
        : left(std::move(_left)), op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Binary> create(
        std::unique_ptr<Expr> _left,
        Token _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Binary>(std::move(_left), _op, std::move(_right));
    }
    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
};

class Logical : public Expr {
public:
    std::unique_ptr<Expr> left;
    Token op;
    std::unique_ptr<Expr> right;

    Logical(std::unique_ptr<Expr> _left, Token _op, std::unique_ptr<Expr> _right)
        : left(std::move(_left)), op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Logical> create(
        std::unique_ptr<Expr> _left,
        Token _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Logical>(std::move(_left), _op, std::move(_right));
    }
    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
};

class Grouping : public Expr {
public:
    std::unique_ptr<Expr> expression;

    Grouping(std::unique_ptr<Expr> _expression)
        : expression(std::move(_expression)) {}

    static std::unique_ptr<Grouping> create(std::unique_ptr<Expr> _expression) {
        return std::make_unique<Grouping>(std::move(_expression));
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
};

class Literal : public Expr {
public:
    Value value;

    Literal(Value _value)
        : value(_value) {}

    static std::unique_ptr<Literal> create(Value _value) {
        return std::make_unique<Literal>(_value);
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
};

class Unary : public Expr {
public:
    Token op;
    std::unique_ptr<Expr> right;

    Unary(const Token& _op, std::unique_ptr<Expr> _right)
        : op(_op), right(std::move(_right)) {}

    static std::unique_ptr<Unary> create(
        const Token& _op,
        std::unique_ptr<Expr> _right) {
        return std::make_unique<Unary>(_op, std::move(_right));
    }

    void accept(ExprVisitor& visitor) const override {
        return visitor.visit(*this);
    }
};


class Variable : public Expr {
public:
    Token name;

    explicit Variable(const Token& name): name(name) {}
    static std::unique_ptr<Variable> create(const Token& name) {
        return std::make_unique<Variable>(name);
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
};

class Assignment : public Expr {
public:
    Token name;
    std::unique_ptr<Expr> right;

    Assignment(const Token& _name, std::unique_ptr<Expr> _right): name(_name), right(std::move(_right)) {}
    static std::unique_ptr<Assignment> create(const Token& _name, std::unique_ptr<Expr> _right) {
        return std::make_unique<Assignment>(_name, std::move(_right));
    }

    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
};

class Call : public Expr {
public:
    std::unique_ptr<Expr> callee;
    Token paren;
    std::vector<std::unique_ptr<Expr>> arguments;

    Call(std::unique_ptr<Expr> _callee, Token _paren, std::vector<std::unique_ptr<Expr>> _arguments)
        : callee(std::move(_callee)), paren(_paren), arguments(std::move(_arguments)) {
    }
    static std::unique_ptr<Call> create(std::unique_ptr<Expr> _callee, Token _paren, std::vector<std::unique_ptr<Expr>> _arguments) {
        return std::make_unique<Call>(std::move(_callee), std::move(_paren), std::move(_arguments));
    }
    void accept(ExprVisitor& visitor) const override {
        visitor.visit(*this);
    }
};
